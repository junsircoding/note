概述
----

正则表达式（Regular Expression）是一个`字符串序列`，它描述了一个对`文本`的`搜索规则`。
这种搜索规则被用到`字符串搜索算法`当中，这个算法可以对字符串进行`查找`和`替换`操作，还可以对输入的字符串进行`校验`。
`字符串搜索算法`是从`理论计算机科学（Theoretical Computer Science）`和`形式语言（Formal Language）`中发展而来的。

正则表达式的理论开始于 20 世纪 50 年代，那时有个叫 Stephen Cole Kleene 的数学家定义了正则表达式。它们与 Unix 文本处理实用程序一起使用。自 1980 年代以来，编写正则表达式的不同语法已经存在，一种是 POSIX 标准，另一种被广泛使用的是 Perl 语法。

正则表达式用于搜索引擎、文字处理器和文本编辑器的搜索和替换对话框、文本处理实用程序（如 sed 和 AWK）以及词法分析。许多编程语言提供内置或通过库的正则表达式功能，因为它在许多情况下都有使用。

历史
----

正则表达式起源于 1951 年，当时数学家 Stephen Cole Kleene 使用称为常规事件的数学符号来描述正则语言。这些出现在`理论计算机科学`、`自动机理论（计算模型）`的子领域以及`形式语言`的描述和分类中。其他早期的模式匹配实现包括 SNOBOL 语言，它不使用正则表达式，而是使用自己的模式匹配结构。

正则表达式从 1968 年开始以两种用途流行起来：文本编辑器中的模式匹配和编译器中的词法分析。正则表达式以程序形式首次出现是当 Ken Thompson 将 Kleene 的符号构建到编辑器 QED 中作为匹配文本文件中模式的一种手段时。为提高速度，Thompson 通过即时编译 (JIT) 与 Compatible Time-Sharing System 上的 IBM 7094 代码实现了正则表达式匹配，这是 JIT 编译的一个重要早期示例。后来他在 Unix 编辑器 `ed` 中添加了这个功能，最终导致流行的搜索工具 `grep` 使用正则表达式（「grep」是一个词，源自 `ed` 编辑器中用于正则表达式搜索的命令：`g/re/p`，其含义为「全局搜索正则表达式和打印匹配行」）。大约在 Thompson 开发 QED 的同时，包括 Douglas T. Ross 在内的一组研究人员实现了一个基于正则表达式的工具，用于编译器设计中的词法分析。

20 世纪 70 年代贝尔实验室的 Unix 程序（包括 `vi`、`lex`、`sed`、`AWK` 和 `expr`）以及 `Emacs` 等其他程序中使用了这些原始形式的正则表达式的许多变体。正则表达式随后被广泛的程序采用，这些早期形式于 1992 年在 POSIX.2 标准中标准化。

在 1980 年代，更复杂的正则表达式出现在 Perl 中，它最初源自 Henry Spencer (1986) 编写的正则表达式库，后来他为 Tcl 编写了高级正则表达式的实现。Tcl 库是具有改进的性能特征的混合 NFA/DFA 实现。采用 Spencer 的 Tcl 正则表达式实现的软件项目包括 PostgreSQL。Perl 后来扩展了 Spencer 的原始库以添加许多新功能。设计 Raku（以前称为 Perl 6）的部分工作是改进 Perl 的正则表达式集成，并增加它们的范围和功能以允许定义解析表达式语法。结果是一种称为 Raku 规则的迷你语言，用于定义 Raku 语法并为该语言的程序员提供工具。这些规则保留了 Perl 5.x 正则表达式的现有特性，但也允许通过子规则以 BNF 样式定义递归下降解析器。

正则表达式在文档和数据库建模的结构化信息标准中的使用始于 1960 年代，并在 1980 年代在 ISO SGML（由 ANSI“GCA 101-1983”前身）等行业标准合并时得到扩展。结构规范语言标准的内核由正则表达式组成。它的使用在 DTD 元素组语法中很明显。

从 1997 年开始，Philip Hazel 开发了 PCRE（Perl Compatible Regular Expressions），它试图密切模仿 Perl 的正则表达式功能，并被包括 PHP 和 Apache HTTP Server 在内的许多现代工具使用。

今天，正则表达式在编程语言、文本处理程序（尤其是词法分析器）、高级文本编辑器和其他一些程序中得到广泛支持。 正则表达式支持是许多编程语言（包括 Java 和 Python）标准库的一部分，并且内置于其他语言（包括 Perl 和 ECMAScript）的语法中。正则表达式功能的实现通常称为正则表达式引擎，并且有许多库可供重用。在 2010 年代后期，几家公司开始提供与 CPU 实现相比更快的 PCRE 兼容正则表达式引擎的硬件、FPGA、GPU 实现。

Patterns
----

短语正则表达式或正则表达式通常用于表示特定的标准文本语法，用于表示匹配文本的模式，这与下面描述的数学符号不同。正则表达式中的每个字符（即描述其模式的字符串中的每个字符）要么是具有特殊含义的元字符，要么是具有字面意义的常规字符。例如，在正则表达式 `b.` 中，`b` 是仅匹配 `b` 的文字字符，而 `.` 是一个元字符，它匹配除 `\n` 以外的所有字符。因此，此正则表达式匹配，例如，`b%`、`bx` 或 `b5`。

元字符和文字字符一起可用于识别给定模式的文本或处理它的多个实例。模式匹配可以从精确的相等到非常普遍的相似，由元字符控制。例如，`.` 是一个非常通用的模式，`[a-z]`（匹配从 `a` 到 `z` 的所有小写字母）不太通用，`b` 是一个精确模式（仅匹配 `b`）。

元字符语法专门设计用于以简洁灵活的方式表示规定的目标，以指导各种输入数据的文本处理的自动化，以易于使用标准 ASCII 键盘键入的形式。

这种语法中正则表达式的一个非常简单的例子是在文本编辑器中定位一个以两种不同方式拼写的单词，正则表达式 `seriali[sz]e` 匹配 `serialise` 和 `serialize`。通配符也可以实现这一点，但它们可以模式化的内容更加有限，因为它们具有较少的元字符和简单的语言库。

通配符的通常上下文是在文件列表中通配相似的名称，而正则表达式通常用于模式匹配文本字符串的应用程序中。例如，正则表达式 `^[\t]+|[\t]+$` 匹配行首或行尾多余的空格。匹配任何数字的高级正则表达式是 `[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?`。

正则表达式处理器将上述语法中的正则表达式转换为内部表示，该表示可以执行并与表示正在搜索的文本的字符串匹配。一种可能的方法是 Thompson 构造算法来构造非确定性有限自动机（NFA），然后将其确定为确定性，并在目标文本字符串上运行生成的确定性有限自动机（DFA），以识别与正则表达式匹配的子字符串。

图为从正则表达式 `s*` 得到的 NFA 方案 `N(s*)`，其中 `s` 依次表示一个更简单的正则表达式，已经递归翻译成`NFA N(s)`。

![Thompson-kleene-star](./files/img/1006px-Thompson-kleene-star.png)

平移 Kleene 星（`s*` 表示「零个或多个`s`」）

基本概念
----

正则表达式，通常称为模式，指定特定目的所需的一组字符串。指定有限字符串集的一种简单方法是列出其元素或成员。但是，通常有更简洁的方法：例如，包含三个字符串「Handel」、「Händel」和「Haendel」的集合可以通过模式 `H(ä|ae?)ndel` 来指定；我们说这个模式匹配三个字符串中的每一个。在大多数形式中，如果至少存在一个匹配特定集合的正则表达式，那么存在无限数量的其他正则表达式也匹配它——规范不是唯一的。大多数形式主义提供以下操作来构造正则表达式。

### 布尔「or」

`gray|grey` 可以匹配「gray」或「grey」。

### 分组

括号用于定义运算符的范围和优先级（以及其他用途）。 例如，`gray|grey `和 `gr(a|e)y` 是等效的模式，它们都描述了「gray」或「grey」的集合。

### 量化

标记（例如字符）或组之后的量词指定允许前面的元素出现的频率。 最常见的量词是问号 `?`、星号 `*`（源自 Kleene 星）和加号 `+`（Kleene plus）。

| 正则 | 描述 |
| ---- | ---- |
| `?` | 问号表示前面的元素出现零次或一次。 例如，colou?r 匹配“color”和“color”。|
| `*` | 星号表示前面的元素出现零次或多次。 例如，ab*c 匹配“ac”、“abc”、“abbc”、“abbbc”等。 |
| `+`  | 加号表示前面元素出现一次或多次。 例如，ab+c 匹配“abc”、“abbc”、“abbbc”等，但不匹配“ac”。 |
| `{n}`  | 前一项恰好匹配 n 次。 |
| `{min,}`  | 前一项匹配最少或更多次。 |
| `{,max}`  | 前一项匹配到最大次数。 |
| `{min,max}`  | 前一项至少匹配 min 次，但不超过 max 次。 |

### 通配符

通配符`.`匹配任何字符。 例如，`a.b` 匹配任何包含`a`的字符串，然后是任何字符，然后是`b`。
`a.*b` 匹配任何包含`a`的字符串，然后是字符`b`。

这些结构可以组合形成任意复杂的表达式，就像可以从数字和运算 `+`、`-`、`×` 和 `÷` 构建算术表达式一样。 例如，`H(ae?|ä)ndel` 和 `H(a|ae|ä)ndel` 都是有效模式，它们与前面的示例 `H(ä|ae?)ndel` 匹配相同的字符串。

正则表达式的精确语法因工具和上下文而异； §语法中给出了更多细节。

https://en.wikipedia.org/wiki/Regular_expression