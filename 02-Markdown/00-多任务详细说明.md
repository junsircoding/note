你了解多线程吗?

当我们在讨论 Python 多线程或多进程的问题时, 我们其实是想搞清楚在不同的硬件, 不同的操作系统, 不同的 Python 版本, 不同的程序算法逻辑, 执行多任务的各种方案各自的优缺点.

因为我们的服务大多是部署在 Linux 系统上, 所以不讨论 Windows 和 Mac 系统的服务器.

硬件方面需要考虑的就是 CPU, CPU 粗略的可以分为单核 CPU 和多核 CPU.

硬件如果没有软件去驱动就只是一块电路板, 所以需要知道操作系统软件是如何组织这些任务并把它们分配给 CPU 去执行.

操作系统进行资源调度和分配的的基本单位是进程, CPU 调度和分配的基本单位是线程. 线程不能脱离进程而存在, 必须先创建进程才能在这个进程里面创建线程.

CPU 的一个核心一次只能执行一个线程, 如果一定要同时执行多个线程, 就需要用调度的方式让多个线程交替执行. 这里就引出了并发和并行的概念. 并发是看上去同时在执行多个任务, 实际上是调度交替执行产生的错觉, 并行是真正的同时在执行多个任务. 所以单核 CPU 的多任务是并发, 多核 CPU 的多任务是并行.

我们用 Python 写多线程的代码的时候会导入 threading 模块直接创建线程, 其实这个线程也是包含在当前程序的主进程当中的.

不同编程语言实现多进程, 多线程的方式不同, 对于 Python 来说, 一个需要注意的点就是 Python 每个进程会有一个全局 GIL 锁, 多线程执行的时候回去竞争这个 GIL 锁, 拿到锁的线程才能执行, 执行到设定的阈值时间之后会释放锁, 将其交给下一个线程.

Python 2 和 Python 3 中对于这个执行时间的阈值计算有区别. Python 2 的计数方式对于 CPU 密集型的程序不友好, Python 3 中改善了一些, 但效果不明显.


| CPU 种类 | Python 版本 | 算法特点 | 多任务方案 | 评价 |
| ---- | ---- | ---- | ---- | ---- |
| 单核 | Python 2 | CPU 密集型 | 多进程 | |
| 单核 | Python 2 | CPU 密集型 | 多线程 | |
| 单核 | Python 2 | IO 密集型 | 多进程 | |
| 单核 | Python 2 | IO 密集型 | 多线程 | |
| 单核 | Python 3 | CPU 密集型 | 多进程 | |
| 单核 | Python 3 | CPU 密集型 | 多线程 | |
| 单核 | Python 3 | IO 密集型 | 多进程 | |
| 单核 | Python 3 | IO 密集型 | 多线程 | |
| 多核 | Python 2 | CPU 密集型 | 多进程 | |
| 多核 | Python 2 | CPU 密集型 | 多线程 | |
| 多核 | Python 2 | IO 密集型 | 多进程 | |
| 多核 | Python 2 | IO 密集型 | 多线程 | |
| 多核 | Python 3 | CPU 密集型 | 多进程 | 区别不大. 创建进程的开销创建线程的开销, 但切换线程开销也比较大, 所以 CPU 密集型的算法使用多进程和多线程区别不大.|
| 多核 | Python 3 | CPU 密集型 | 多线程 | 区别不大. 创建进程的开销创建线程的开销, 但切换线程开销也比较大, 所以 CPU 密集型的算法使用多进程和多线程区别不大.|
| 多核 | Python 3 | IO 密集型 | 多进程 | 好. 每个进程有各自独立的 GIL，互不干扰, 这样就可以真正意义上的并行执行. |
| 多核 | Python 3 | IO 密集型 | 多线程 | 不好. 单核下多线程, 每次释放 GIL，唤醒的那个线程都能获取到 GIL 锁，所以能够无缝执行，但多核下，CPU 0号核心 释放 GIL 后, 其他CPU 上的线程都会进行竞争, 但 GIL 可能会马上又被 CPU 0号核心 拿到, 导致其他几个 CPU 上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态, 这样会造成线程颠簸(thrashing)，导致效率更低 |

协程本质上是当线程, 不涉及锁的竞争和资源开销问题.