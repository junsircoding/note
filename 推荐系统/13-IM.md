# 即时通讯IM

即时通讯（Instant Messaging）是一种基于互联网的即时交流消息的业务。

类型：

* 在线push
  * 适用：web页面 和 App
  * 自己构建IM服务器
    * 使用WebSocket
    * 采用成熟的框架方案Socket.IO
    * 对于App还可自己封装socket
  * 使用第三方IM服务商提供的服务

* 离线push
  * 适用：App
  * 对于iOS，使用APNs
  * 对于andorid，使用FCM（国外）或第三方IM服务商提供的服务

提供第三方IM服务的服务商有：

* 网易云信
* 融云
* 环信
* LeanCloud

**下面只针对 「在线推送」 的自建方案来展开讲解。**

### 需求场景

服务端需要主动推送消息给客户端，例如

* 用户下了订单，需要在运营管理后台向运营人员推送新订单通知
* 用户A关注了用户B，系统需要向用户B推送提示消息
* 即时聊天

### 传统的推送实现

HTTP/1.x 不支持服务器主动推送，只能在客户端发起请求后做出回应。 （HTTP/2支持服务器主动推送，但HTTP/2 还未全面实施）

* 轮询

  轮询是在特定的的时间间隔（如每1秒），由客户端对服务器发出HTTP请求，了解服务器有没有新的信息，然后由服务器告知有无新数据或返回最新的数据给客户端。

  缺点：

  * 效率低下，浪费资源

    必须不停连接，或者连接始终打开，但传输HTTP请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。

* Comet （基于长连接）

  * 长轮询
    长轮询是在打开一条连接以后保持，等待服务器推送来数据再关闭的方式。
  * iframe流
    iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长链接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。

  缺点：

  依然需要反复发出请求，而且长连接也会消耗服务器资源。

###WebSocket

**HTML5定义了WebSocket协议**，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。

在2008年诞生，2011年成为国际标准。

现在基本所有浏览器都已经支持了。

WebSocket是一种在单个TCP连接上进行全双工通信的协议。**在WebSocket API中，浏览器和服务器只需要完成一次握手（不是指建立TCP连接的那个三次握手，是指在建立TCP连接后传输一次握手数据），两者之间就直接可以创建持久性的连接，并进行双向数据传输。**

![websocket](images/websocket.png)

Websocket使用ws或wss的统一资源标志符，类似于HTTPS，其中wss表示在TLS之上的Websocket。如：

```
ws://example.com/wsapi
wss://secure.example.com/
```

Websocket使用和 HTTP 相同的 TCP 端口，可以绕过大多数防火墙的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。

![ws与http](images/ws与http.jpg)

#### 握手协议

WebSocket 是独立的、创建在 TCP 上的协议。  报文

**Websocket 通过 HTTP/1.1 协议的101状态码进行握手。**

为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。

一个典型的Websocket握手请求如下：

客户端请求

```http
GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: example.com
Origin: http://example.com
Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==
Sec-WebSocket-Version: 13
```

服务器回应

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=
Sec-WebSocket-Location: ws://example.com/
```

- Connection必须设置Upgrade，表示客户端希望连接升级。
- Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。
- Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算SHA-1摘要，之后进行BASE-64编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，**可以尽量避免普通HTTP请求被误认为Websocket协议。**
- Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。
- Origin字段是可选的，通常用来表示在浏览器中发起此Websocket连接所在的页面，类似于Referer。但是，与Referer不同的是，Origin只包含了协议和主机名称。
- 其他一些定义在HTTP协议中的字段，如Cookie等，也可以在Websocket中使用。

#### 优点

* **较少的控制开销。**在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。**相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。**
* **更强的实时性。**由于协议是全双工的，所以**服务器可以随时主动给客户端下发数据。**相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。
* **保持连接状态。**与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。
  更好的二进制支持。**Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。**
* **可以支持扩展**。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。
* **更好的压缩效果**。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。
* **没有同源限制，客户端可以与任意服务器通信。**
* **可以发送文本，也可以发送二进制数据。**

#### Web客户端的简单示例

WebSocket 的用法相当简单。 javascript

```javascript
var ws = new WebSocket("wss://echo.websocket.org");

ws.onopen = function(evt) { 
  console.log("Connection open ..."); 
  ws.send("Hello WebSockets!");
};

ws.onmessage = function(evt) {
  console.log( "Received Message: " + evt.data);
  ws.close();
};

ws.onclose = function(evt) {
  console.log("Connection closed.");
};      
```

#### WebSocket 客户端API 介绍

##### 1 WebSocket 构造函数

WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。

```javascript
var ws = new WebSocket('ws://localhost:8080');
```

执行上面语句之后，客户端就会与服务器进行连接。

##### 2 webSocket.readyState

`readyState`属性返回实例对象的当前状态，共有四种。

- CONNECTING：值为0，表示正在连接。
- OPEN：值为1，表示连接成功，可以通信了。
- CLOSING：值为2，表示连接正在关闭。
- CLOSED：值为3，表示连接已经关闭，或者打开连接失败。

下面是一个示例。

```javascript
switch (ws.readyState) {
  case WebSocket.CONNECTING:
    // do something
    break;
  case WebSocket.OPEN:
    // do something
    break;
  case WebSocket.CLOSING:
    // do something
    break;
  case WebSocket.CLOSED:
    // do something
    break;
  default:
    // this never happens
    break;
}
```

##### 3 webSocket.onopen 连接成功

实例对象的`onopen`属性，用于指定连接成功后的回调函数。

```javascript
ws.onopen = function () {
  ws.send('Hello Server!');
}
```

如果要指定多个回调函数，可以使用`addEventListener`方法。

```javascript
ws.addEventListener('open', function (event) {
  ws.send('Hello Server!');
});
```

##### 4 webSocket.onclose 关闭连接后

实例对象的`onclose`属性，用于指定连接关闭后的回调函数。

```javascript
ws.onclose = function(event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
};

ws.addEventListener("close", function(event) {
  var code = event.code;
  var reason = event.reason;
  var wasClean = event.wasClean;
  // handle close event
});
```

##### 5 webSocket.onmessage 收到消息时

实例对象的`onmessage`属性，用于指定收到服务器数据后的回调函数。

```javascript
ws.onmessage = function(event) {
  var data = event.data;
  // 处理数据
};

ws.addEventListener("message", function(event) {
  var data = event.data;
  // 处理数据
});
```

##### 6 webSocket.send()  发送消息

实例对象的`send()`方法用于向服务器发送数据。

```javascript
ws.send('your message');
```

##### 7 webSocket.bufferedAmount

实例对象的`bufferedAmount`属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。

```javascript
var data = new ArrayBuffer(10000000);
socket.send(data);

if (socket.bufferedAmount === 0) {
  // 发送完毕
} else {
  // 发送还没结束
}
```

##### 8 webSocket.onerror 出现错误

实例对象的`onerror`属性，用于指定报错时的回调函数。

```javascript
socket.onerror = function(event) {
  // handle error event
};

socket.addEventListener("error", function(event) {
  // handle error event
});
```

###Socket.IO

 **Socket.IO 本是一个面向实时 web 应用的 JavaScript 库，现在已成为拥有众多语言支持的Web即时通讯应用的框架。**

Socket.IO 主要使用WebSocket协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如Adobe Flash Sockets，JSONP拉取，或是传统的AJAX拉取，并且在同时提供完全相同的接口。尽管它可以被用作WebSocket的包装库，它还是提供了许多其它功能，比如广播至多个套接字，存储与不同客户有关的数据，和异步IO操作。

**Socket.IO  不等价于 WebSocket**，WebSocket只是Socket.IO实现即时通讯的其中一种技术依赖，而且Socket.IO还在实现WebSocket协议时做了一些调整。

##### 优点：

Socket.IO 会自动选择合适双向通信协议，仅仅需要程序员对套接字的概念有所了解。

有Python库的实现，可以在Python实现的Web应用中去实现IM后台服务。

##### 缺点：

Socket.io并不是一个基本的、独立的、能够回退到其它实时协议的WebSocket库，它实际上是一个依赖于其它实时传输协议的自定义实时传输协议的实现。**该协议的协商部分使得支持标准WebSocket的客户端不能直接连接到Socket.io服务器，并且支持Socket.io的客户端也不能与非Socket.io框架的WebSocket或Comet服务器通信。因而，Socket.io要求客户端与服务器端均须使用该框架。**

```python
              客户端									服务器                  HTTP通讯  客户端       服务器
应用程序代码	Socket.IO            Socket.IO 										js APP 浏览器  Flask/Django
应用层协议    WebSocket/HTTP				WebSocket/HTTP                    HTTP				HTTP
传输层				TCP  								 TCP																TCP   			TCP

```



### Socket.IO Python服务器端开发

文档<https://python-socketio.readthedocs.io/en/latest/server.html>

#### 安装

```python
pip install python-socketio
```

#### 创建服务器

方式1: 使用多进程多线程模式的WSGI服务器对接（如uWSGI、gunicorn)

```python
import socketio  

# create a Socket.IO servers
sio = socketio.Server()

# 打包成WSGI应用，可以使用WSGI服务器托管运行
app = socketio.WSGIApp(sio)  # Flask  Django
```

方式2: 作为Flask、Django 应用中的一部分

```python
from wsgi import app  # a Flask, Django, etc. application
import socketio

# create a Socket.IO server
sio = socketio.Server()

app = socketio.WSGIApp(sio, app)
```

方式3: 使用协程的方式运行

这里采用Eventlet 服务器  yield

```python
import eventlet
eventlet.monkey_patch()

# monkey_patch的作用是替换了标准原生python中的io操作函数或方法，改为协程库中提供的同名方法
# 协程库中同名方法的作用那个是可以自动切换协程
# f = open()
# f.read()
# f.write()
# 
# socket = Socket()
# socket.connect()
# socket.listen()
#  accept
# 
#   send
#   recv


import socketio
import eventlet.wsgi

sio = socketio.Server(async_mode='eventlet')  # 指明在evenlet模式下
app = socketio.Middleware(sio)
eventlet.wsgi.server(eventlet.listen(('', 8000)), app)
```

#### 事件处理

```python
@sio.on('my custom event')  # 以字符串的形式表示一个事件，事件的定义由前后端约定
def my_custom_event(sid, data):
    pass
  
  
  
@app.route('/index')
def index():
	pass
```

* connect 为特殊事件，当客户端连接后自动执行
* disconnect 为特殊事件，当客户端断开连接后自动执行
* 事件

群发

```python
sio.emit('my event', {'data': 'foobar'})
```

发送给指定用户

```python
sio.emit('my event', {'data': 'foobar'}, room=user_sid)
```

对于'message'事件，可以使用send方法

```python
sio.send({'data': 'foobar'})
sio.send({'data': 'foobar'}, room=user_sid)
```

#### Rooms

```python
@sio.on('chat')
def begin_chat(sid):
   sio.enter_room(sid, 'chat_users')

@sio.on('exit_chat')
def exit_chat(sid):
     sio.leave_room(sid, 'chat_users')
    
@sio.on('my message')
def message(sid, data):
    sio.emit('my reply', data, room='chat_users', skip_sid=sid)
    
# 获取room
sio.rooms(sid)
```

#### 案例

server.py

```python
import socketio

sio = socketio.Server(async_mode='eventlet')
app = socketio.Middleware(sio)
```

main.py

```python
import eventlet
eventlet.monkey_patch()

import eventlet.wsgi
import sys


if len(sys.argv) < 2:
    print('Usage: python main.py [port]')
    exit(1)

port = int(sys.argv[1])

from server import app
import notify
server_address = ('', port)
sock = eventlet.listen(server_address)
eventlet.wsgi.server(sock, app)
```

notify.py

```python
from server import sio
import time


@sio.on('connect')
def on_connect(sid, environ):
    timestamp = int(time.time())
    sio.send({'msg': 'hello this is message event msg', 'timestamp': timestamp})
    sio.emit('notify', {'msg': 'hi, this is notify event msg', 'timestamp': timestamp})
    sio.enter_room(sid, 'notify room')


@sio.on('disconnect')
def on_disconnect(sid):
    sio.leave_room(sid, 'notify room')


@sio.on('notify')
def on_notify(sid, data):
    print(data)
    sio.emit('notify', 'I have received your msg: {}'.format(data))
```

#### 使用firecamp.app进行测试

![firecamp](images/firecamp_sio.png)

#### 使用消息队列对接其他系统

##### 需求：

在头条的Flask应用中，用户关注后需要推送消息，通过消息队列告知IM服务为用户进行推送

* 使用Redis

  ```python
  mgr = socketio.RedisManager('redis://')
  sio = socketio.Server(client_manager=mgr)
  ```

* 使用RabbitMQ

  ```shell
  pip install kombu
  ```

  ```python
  mgr = socketio.KombuManager('amqp://')
  sio = socketio.Server(client_manager=mgr)
  ```

##### 实现

main.py

```python
import eventlet
eventlet.monkey_patch()

import eventlet.wsgi
import sys
import os


BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, os.path.join(BASE_DIR, 'common'))


if len(sys.argv) < 2:
    print('Usage: python main.py [port]')
    exit(1)

port = int(sys.argv[1])

from server import app
import notify
server_address = ('', port)
sock = eventlet.listen(server_address)
eventlet.wsgi.server(sock, app)
```

server.py

```python
import socketio

RABBITMQ = 'amqp://python:rabbitmqpwd@localhost:5672/toutiao'
JWT_SECRET = 'TPmi4aLWRbyVq8zu9v82dWYW17/z+UvRnYTt4P6fAXA'

mgr = socketio.KombuManager(RABBITMQ)

sio = socketio.Server(async_mode='eventlet', client_manager=mgr)
app = socketio.Middleware(sio)
```

notify.py

```python
from server import sio, JWT_SECRET
import time
from werkzeug.wrappers import Request
from utils.jwt_util import verify_jwt


def check_jwt_token(environ):
    request = Request(environ)
    token = request.args.get('token')
    print(token)
    if token:
        payload = verify_jwt(token, secret=JWT_SECRET)
        if payload:
            user_id = payload.get('user_id')
            return user_id
    return None


@sio.on('connect')
def on_connect(sid, environ):
    timestamp = int(time.time())
    sio.send({'msg': 'hello this is message event msg', 'timestamp': timestamp})
    sio.emit('notify', {'msg': 'hi, this is notify event msg', 'timestamp': timestamp})

    user_id = check_jwt_token(environ)
    if user_id is None:
        return False

    sio.enter_room(sid, str(user_id))


@sio.on('disconnect')
def on_disconnect(sid):
    rooms = sio.rooms(sid)
    for room in rooms:
        sio.leave_room(sid, room)


@sio.on('notify')
def on_notify(sid, data):
    print(data)
    sio.emit('notify', 'I have received your msg: {}'.format(data))
```

### Socket.IO Python客户端

```python
import socketio

sio = socketio.Client()

@sio.on('connect')
def on_connect():
  pass

@sio.on('event')
def on_event(data):
  pass

sio.connect('http://10.211.55.7:8000')
sio.wait()
```

