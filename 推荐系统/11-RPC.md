# RPC简介

## 1. 什么是RPC

**远程过程调用**（英语：**Remote Procedure Call**，缩写为 **RPC**，也叫**远程程序调用**）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作**远程调用**或**远程方法调用**。

![RPC示意图](images/RPC%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

## 2. 背景与用途

在单台计算机中，我们可以通过程序调用来传递控制和数据；或者说通过程序调用，我们可以将多个程序组成一个整体来实现某个功能。

如果将这种调用机制推广到多台彼此间可以进行网络通讯的计算机，由多台计算机中的多个程序组成一个整体来实现某个功能，这也是可以的。调用的一方（发起远程过程调用，然后调用这方的环境挂起，参数通过网络传递给被调用方，被调用的一方执行程序，当程序执行完成后，产生的结果再通过网络回传给调用的一方，调用的一方恢复继续执行。这样一种原型思想，就是我们所说的RPC远程过程调用。

![单机到多机](images/%E5%8D%95%E6%9C%BA%E5%88%B0%E5%A4%9A%E6%9C%BA.png)

RPC这种思想最早可以追溯到1976年，RPC的发展到今天已经40年有余了。

如今的计算机应用中，单机性能上很难承受住产品的压力，需要不断扩充多台机器来提升整体的性能。同时为了充分利用这些集群里的计算机，需要对其从架构上进行划分，以提供不同的服务，服务间相互调用完成整个产品的功能。RPC就能帮助我们解决这些服务间的信息传递和调用。

## 3. 概念说明

关于RPC的概念，我们可以从广义和狭义来分别进行理解。

#### 广义

我们可以将所有通过网络来进行通讯调用的实现统称为RPC。

按照这样来理解的话，那我们发现HTTP其实也算是一种RPC实现。

![HTTP](images/HTTP.png)

#### 狭义

区别于HTTP的实现方式，在传输的数据格式上和传输的控制上独立实现。比如在机器间通讯传输的数据不采用HTTP协议的方式（分为起始行、header、body三部份），而是使用自定义格式的二进制方式。

我们更多时候谈到的RPC都是指代这种狭义上的理解。

## 4. 优缺点

相比于传统HTTP的实现而言：

#### 优点

- 效率高
- 发起RPC调用的一方，在编写代码时可忽略RPC的具体实现，如同编写本地函数调用一样

#### 缺点

- 通用性不如HTTP好 
  因为传输的数据不是HTTP协议格式，所以调用双方需要专门实现的通信库，对于不同的编程开发语言，都要有相关实现。而HTTP作为一个标准协议，大部分的语言都已有相关的实现，通用性更好。

HTTP更多的面向用户与产品服务器的通讯。

RPC更多的面向产品内部服务器间的通讯。 thrift

# RPC结构

RPC的设计思想是力图**使远程调用中的通讯细节对于使用者透明**，调用双方无需关心网络通讯的具体实现。因而实现RPC要进行一定的封装。

RPC原理上是按如下结构流程进行实现的。

![RPC结构](images/RPC%E7%BB%93%E6%9E%84.png)

#### 流程：

1. 调用者（Caller, 也叫客户端、Client）以本地调用的方式发起调用；
2. Client stub（客户端存根，可理解为辅助助手）收到调用后，负责将被调用的方法名、参数等打包编码成特定格式的能进行网络传输的消息体；
3. Client stub将消息体通过网络发送给对端（服务端）
4. Server stub（服务端存根，同样可理解为辅助助手）收到通过网络接收到消息后按照相应格式进行拆包解码，获取方法名和参数；
5. Server stub根据方法名和参数进行本地调用；
6. 被调用者（Callee，也叫Server）本地调用执行后将结果返回给server stub;
7. Server stub将返回值打包编码成消息，并通过网络发送给对端（客户端）；
8. Client stub收到消息后，进行拆包解码，返回给Client；
9. Client得到本次RPC调用的最终结果。



**RPC的目标就是要2~8这些步骤都封装起来，让使用者对这些细节透明。**

在了解了RPC流程之后，为了实现RPC，我们还需要关注两点：

- **消息协议**

  客户端调用的参数和服务端的返回值这些在网络上传输的数据以何种方式打包编码和拆包解码。

  我们可以使用HTTP协议中关于报文格式的规定（如此一来，就编程了HTTP通讯），也可以自己定义某种格式，让客户端与服务端双方都遵循此种格式。

- **传输控制**

  在网络中数据的收发传输控制具体如何实现。

# RPC消息协议

在实现RPC调用时，通讯双方传输的数据（消息）如何表达描述，设计时一般会考虑两个**目标**：

- **性能高**

  性能高包括两点：

  1. 将原始数据转换为消息数据的速度快
  2. 转换后的消息数据体积小

- **跨语言**

  RPC调用没有要求调用双方的编程语言必须相同，如果能做到跨语言调用是最好，这会方便产品开发中不同的功能服务以最合适的语言实现，然后使用RPC实现彼此调用。因此RPC调用中传输的消息数据应该尽量能让跟多的语言支持。

  **本课程中仅以Python为例进行讲解。**

## 1. 边界

在网络传输中，一方可能连续向另一方多次发送消息，收到数据的一方如何界定数据中包含几条消息，这便是消息边界问题。

考虑TCP传输控制协议，在一条TCP链接中可以多次发送数据，如果发送的数据过大，就会被TCP底层实现拆解为多个数据包依次发送；而如果发送的数据过小，又可能会将几条数据组装成一个数据包进行发送。

为了解决消息边界的问题，有两种较为常用的方法：**分割符法**和**长度声明法**。

#### 分割符法

顾名思义，就是在每条消息的结尾放置一种特殊的分割符（一种常用的分割符是\r\n），表示已到达本条消息的末尾。

![特殊分割符](images/%E7%89%B9%E6%AE%8A%E5%88%86%E5%89%B2%E7%AC%A6.png)

#### 长度声明法

长度声明法是在消息的起始位置，用一个固定长度的整数值（通常为4字节）声明本消息的长度，接收者先读取出长度声明，再按照声明的长度读取出相应大小的数据即可。

![长度声明](images/%E9%95%BF%E5%BA%A6%E5%A3%B0%E6%98%8E.png)

例如，HTTP协议同时运用了这两种方法：

```http
HTTP/1.0 200 OK\r\n
Server: Nginx\r\n
Content-Type: text/html; charset=utf-8\r\n
Content-Length: 5096\r\n
\r\n
# 此处为5096字节的数据
```



## 2. 内容

在具体消息内容的表现形式上，可以使用文本，也可以使用二进制。

#### 文本

我们可以将数据转换为具备某种格式的字符串（如 JSON），将字符串作为消息内容发送。

比如一个RPC调用请求，方法名为divide，参数为200和100，我们可以用JSON字符串的形式来表示这个消息内容：

```json
{
    "name": "divide",
    "params": {
        "num1": 200,
        "num2": 100
    }
}
```

采用JSON这种方式，大多数编程语言都已有JSON转换的工具，实现起来相对便捷。但是我们能够看到，形成的消息数据不够精简，数据中有较为无意义的，如"、{、}、,、空白字符等，在网络传输中会造成浪费。

#### 二进制

二进制方式就是将数据在内存中的一些列原始二进制位或字节直接在网络中传送，而无需转换为字符串再传送。

![二进制传送](images/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%A0%E9%80%81.png)

我们能够看到，采用原始二进制传递，可以省去中间转换的环节，而且数据量也会大大减少，效率更高。

如果使用二进制的方式来传递上面举例的RPC调用请求，该如何组织数据呢？这就需要实现RPC机制的设计人员来制订一个调用双方都遵守的协议规则，不同的设计人员可能有不同的想法。

我们会在稍后的小案例里给大家讲解。



## 3. 压缩

如果消息数据过大，为了减轻网络带宽的压力，可以考虑对消息数据进行压缩处理。

就如同我们平时对一些文件、视频等使用压缩软件进行压缩来减小大小一样，我们可以在构造好数据准备发送前，先用算法将数据进行压缩处理，然后通过网络发送到对端，对端收到数据后，先进行解压缩处理，然后得到原体积数据后再进行解析。

即使是比文本数据小的二进制数据，我们仍然可以进行压缩处理。

但是需要注意的是，压缩处理是一把双刃剑，虽然能减少数据量减轻带宽压力，但是同时额外增加了压缩和解压缩的过程，压缩和解压缩在处理的时候会有时间的消耗，会导致操作系统的负担加重。有时压缩的成本可能比减少数据量带来的收益还高，就得不偿失了。

所以是否采用压缩处理，要根据具体情况权衡利弊。

# RPC传输

在构造好RPC消息数据后，就可以通过网络在调用双方进行传递了。

传递消息数据常用的有两种方式：**TCP** 和 **HTTP**

### 1.  TCP

由于TCP的可靠性，所以TCP是最常用的方式。我们可以直接借助socket工具进行TCP开发。

TCP服务端编写

```python
sock = socket.socket()  # 创建一个套接字
sock.bind()  # 绑定端口
sock.listen()  # 监听连接
sock.accept()  # 接受新连接
sock.close()  # 关闭服务器套接字
```

TCP客户端编写

```python
sock = socket.socket()  # 创建一个套接字
sock.connect()  # 连接远程服务器
sock.recv() # 读
sock.send()  # 尽可能地写
sock.sendall()  # 完全写
sock.close()  # 关闭
```

### 2. HTTP

虽然HTTP属于网络层级中应用层的协议，但是我们仍然可以借助HTTP来帮助我们传递RPC消息。

我们可以将构造好的RPC消息数据嵌入到HTTP报文中的body部分，而对于HTTP的path路径等都无需关心。

```http
HTTP/1.0 POST /
Content-Type: binary
Content-Length: 5096

# 此处放置RPC消息数据
```

使用HTTP作为传输工具的好处是可以直接利用开发语言中已有的http库来进行通讯，无需自己操作socket的读写。但是通讯效率不如TCP高，所以不常用。



